# 微服务架构基础面试题

## 1. 请介绍一下你们项目的整体架构设计

### 回答要点：

**项目概述：**
HMall是一个基于Spring Cloud微服务架构的电商平台，采用前后端分离设计，实现了完整的电商业务流程。

**架构设计：**
- **微服务拆分**：按业务领域拆分为6个核心服务
  - `hm-gateway`：API网关服务，统一入口
  - `user-service`：用户服务，负责用户注册、登录、权限管理
  - `item-service`：商品服务，商品信息、库存管理、搜索
  - `cart-service`：购物车服务，购物车CRUD操作
  - `trade-service`：交易服务，订单创建、状态流转
  - `pay-service`：支付服务，支付流程、回调处理

- **公共模块**：
  - `hm-common`：通用工具类、异常处理、配置
  - `hm-api`：服务间接口定义，实现接口标准化

**技术选型理由：**
- Spring Boot 2.7.12：快速开发，自动配置
- Spring Cloud 2021.0.3：微服务治理框架
- Spring Cloud Alibaba：阿里巴巴微服务生态，更适合国内环境

---

## 2. 为什么选择微服务架构？相比单体架构有什么优势？

### 回答要点：

**选择微服务的原因：**
1. **业务复杂度**：电商系统业务复杂，用户、商品、订单、支付等模块相对独立
2. **团队协作**：不同团队可以独立开发、部署各自负责的服务
3. **技术栈灵活性**：不同服务可以选择最适合的技术栈
4. **扩展性需求**：电商系统需要应对高并发，微服务便于水平扩展

**微服务优势：**
- **独立部署**：服务间解耦，单个服务故障不影响整体系统
- **技术多样性**：每个服务可以选择最适合的技术栈
- **团队自治**：小团队负责端到端的服务开发
- **可扩展性**：可以针对性地扩展高负载服务
- **容错性**：通过熔断、降级机制提高系统稳定性

**面临的挑战及解决方案：**
- **服务间通信**：使用OpenFeign实现声明式服务调用
- **数据一致性**：通过Seata实现分布式事务管理
- **服务治理**：使用Nacos进行服务注册发现和配置管理
- **链路追踪**：可以集成Sleuth进行分布式链路追踪

---

## 3. 你们是如何进行服务拆分的？拆分的原则是什么？

### 回答要点：

**拆分原则：**
1. **业务边界清晰**：按照DDD（领域驱动设计）思想，根据业务领域拆分
2. **数据独立性**：每个服务拥有独立的数据库，避免数据耦合
3. **团队结构**：遵循康威定律，服务边界与团队边界对应
4. **变更频率**：将变更频率相似的功能放在同一服务中

**具体拆分策略：**

**用户服务（user-service）：**
- 职责：用户注册、登录、权限管理、用户信息维护
- 数据：用户基本信息、权限数据
- 边界：用户生命周期管理

**商品服务（item-service）：**
- 职责：商品信息管理、库存管理、商品搜索
- 数据：商品基本信息、库存数据、分类数据
- 边界：商品全生命周期管理

**购物车服务（cart-service）：**
- 职责：购物车CRUD操作、购物车持久化
- 数据：购物车数据、用户购物行为
- 边界：购物车相关操作

**交易服务（trade-service）：**
- 职责：订单创建、订单状态管理、订单查询
- 数据：订单信息、订单状态流转记录
- 边界：订单全生命周期管理

**支付服务（pay-service）：**
- 职责：支付流程、支付回调、支付状态管理
- 数据：支付记录、支付状态
- 边界：支付相关操作

**避免的反模式：**
- 避免按技术层次拆分（如数据层服务、业务层服务）
- 避免过度拆分导致的分布式复杂性
- 避免服务间强耦合和循环依赖

---

## 4. 微服务架构中如何处理数据一致性问题？

### 回答要点：

**数据一致性挑战：**
在微服务架构中，每个服务拥有独立数据库，传统的ACID事务无法跨服务保证数据一致性。

**解决方案：**

**1. 分布式事务（Seata）：**
```java
@GlobalTransactional
public void createOrder(OrderDTO orderDTO) {
    // 1. 创建订单
    Order order = orderService.createOrder(orderDTO);
    
    // 2. 扣减库存（调用商品服务）
    itemService.deductStock(orderDTO.getItems());
    
    // 3. 清空购物车（调用购物车服务）
    cartService.clearCart(orderDTO.getUserId());
}
```

**2. 最终一致性（事件驱动）：**
- 使用消息队列实现异步处理
- 通过补偿机制处理失败场景
- 实现幂等性保证重试安全

**3. 数据一致性策略选择：**
- **强一致性**：订单创建+库存扣减（使用Seata）
- **最终一致性**：积分增加、优惠券使用（异步处理）
- **弱一致性**：用户浏览记录、推荐数据

**实际应用场景：**
- **下单流程**：订单创建、库存扣减、购物车清空需要强一致性
- **支付回调**：支付状态更新、订单状态变更需要最终一致性
- **数据同步**：用户信息变更同步到其他服务可以是最终一致性

---

## 5. 微服务架构的性能如何保证？有哪些优化手段？

### 回答要点：

**性能挑战：**
- 网络延迟：服务间调用增加网络开销
- 序列化开销：数据传输需要序列化/反序列化
- 链路复杂：一个请求可能涉及多个服务调用

**优化策略：**

**1. 服务调用优化：**
```java
// 使用连接池优化HTTP调用
@FeignClient(name = "item-service", configuration = FeignConfig.class)
public interface ItemClient {
    @GetMapping("/items/{id}")
    ItemDTO getById(@PathVariable Long id);
}

// 配置连接池
@Configuration
public class FeignConfig {
    @Bean
    public OkHttpClient okHttpClient() {
        return new OkHttpClient.Builder()
            .connectTimeout(10, TimeUnit.SECONDS)
            .readTimeout(10, TimeUnit.SECONDS)
            .connectionPool(new ConnectionPool(50, 5, TimeUnit.MINUTES))
            .build();
    }
}
```

**2. 缓存策略：**
- **本地缓存**：使用Caffeine缓存热点数据
- **分布式缓存**：Redis缓存用户会话、商品信息
- **多级缓存**：浏览器缓存 + CDN + Redis + 本地缓存

**3. 异步处理：**
- 使用@Async注解实现异步调用
- 消息队列处理非核心业务逻辑
- CompletableFuture并行调用多个服务

**4. 数据库优化：**
- 读写分离：主库写入，从库查询
- 分库分表：按用户ID或订单ID分片
- 索引优化：针对查询场景建立合适索引

**5. 网关层优化：**
- 请求合并：Gateway聚合多个服务调用
- 限流熔断：防止服务雪崩
- 响应压缩：减少网络传输数据量

**监控指标：**
- 响应时间：P99、P95响应时间
- 吞吐量：QPS、TPS指标
- 错误率：服务调用成功率
- 资源使用：CPU、内存、网络使用率