# 分布式系统与一致性面试题

## 1. 什么是CAP理论？在微服务架构中如何权衡？

### 回答要点：

**CAP理论定义：**
- **Consistency（一致性）**：所有节点在同一时间看到相同的数据
- **Availability（可用性）**：系统在任何时候都能响应用户请求
- **Partition Tolerance（分区容错性）**：系统能够容忍网络分区故障

**CAP定理核心：**
分布式系统最多只能同时保证CAP中的两个特性，无法三者兼得。

**在HMall项目中的权衡：**

**1. CP场景（一致性+分区容错）：**
```java
// 订单创建场景：优先保证数据一致性
@GlobalTransactional
public void createOrder(OrderDTO orderDTO) {
    // 1. 创建订单记录
    Order order = buildOrder(orderDTO);
    orderMapper.insert(order);
    
    // 2. 扣减商品库存（必须成功）
    itemClient.deductStock(orderDTO.getItems());
    
    // 3. 清空购物车
    cartClient.clearCart(orderDTO.getUserId());
    
    // 任何一步失败都会回滚，保证数据一致性
    // 但可能因为网络问题导致服务暂时不可用
}
```

**2. AP场景（可用性+分区容错）：**
```java
// 用户浏览记录：优先保证系统可用性
@Async
public void recordUserBehavior(Long userId, Long itemId) {
    try {
        // 异步记录，即使失败也不影响主流程
        behaviorService.record(userId, itemId);
    } catch (Exception e) {
        log.warn("用户行为记录失败，userId: {}, itemId: {}", userId, itemId, e);
        // 系统依然可用，只是丢失了部分行为数据
    }
}
```

**3. 实际应用策略：**
- **核心业务**：订单、支付、库存 → 选择CP，保证数据一致性
- **辅助功能**：推荐、统计、日志 → 选择AP，保证系统可用性
- **查询场景**：商品展示、用户信息 → 最终一致性，提高性能

---

## 2. Seata分布式事务的实现原理是什么？

### 回答要点：

**Seata核心组件：**
1. **TC（Transaction Coordinator）**：事务协调器，管理全局事务
2. **TM（Transaction Manager）**：事务管理器，定义全局事务边界
3. **RM（Resource Manager）**：资源管理器，管理本地事务

**工作流程：**
```
1. TM向TC申请开启全局事务，TC生成全局事务ID(XID)
2. XID通过微服务调用链传播
3. RM向TC注册分支事务，执行业务SQL
4. TM向TC发起全局提交或回滚
5. TC协调所有RM进行分支事务提交或回滚
```

**项目中的配置：**

**1. Seata Server配置：**
```yaml
# application.yml
server:
  port: 7091

spring:
  application:
    name: seata-server

seata:
  config:
    type: nacos
    nacos:
      server-addr: 192.168.150.101:8848
      group: SEATA_GROUP
      namespace: seata
  registry:
    type: nacos
    nacos:
      application: seata-server
      server-addr: 192.168.150.101:8848
      group: SEATA_GROUP
      namespace: seata
```

**2. 客户端配置：**
```yaml
seata:
  registry:
    type: nacos
    nacos:
      server-addr: 192.168.150.101:8848
      group: SEATA_GROUP
      namespace: seata
  tx-service-group: hmall_tx_group
  service:
    vgroup-mapping:
      hmall_tx_group: default
```

**3. 业务代码实现：**
```java
@Service
public class OrderServiceImpl implements IOrderService {
    
    @Autowired
    private OrderMapper orderMapper;
    
    @Autowired
    private ItemClient itemClient;
    
    @Autowired
    private CartClient cartClient;
    
    @Override
    @GlobalTransactional  // 开启全局事务
    public Long createOrder(OrderFormDTO orderFormDTO) {
        // 1. 订单数据
        Order order = new Order();
        // ... 设置订单信息
        
        // 2. 保存订单
        orderMapper.insert(order);
        
        // 3. 扣减库存
        try {
            itemClient.deductStock(orderFormDTO.getDetails());
        } catch (Exception e) {
            throw new BizIllegalException("库存不足！");
        }
        
        // 4. 清理购物车
        cartClient.deleteCartItemByIds(orderFormDTO.getCartIds());
        
        return order.getId();
    }
}
```

**Seata模式对比：**

**AT模式（自动）：**
- 优点：业务代码无侵入，自动生成回滚SQL
- 缺点：依赖数据库本地事务，性能相对较低
- 适用：大部分CRUD场景

**TCC模式（手动）：**
- 优点：性能高，不依赖数据库事务
- 缺点：业务代码侵入性强，需要实现Try、Confirm、Cancel
- 适用：对性能要求极高的场景

**SAGA模式（长事务）：**
- 优点：适合长流程业务
- 缺点：不保证隔离性
- 适用：业务流程长、并发要求不高的场景

---

## 3. 分布式系统中如何保证数据一致性？

### 回答要点：

**一致性级别：**
1. **强一致性**：任何时刻所有节点数据完全一致
2. **弱一致性**：系统不保证何时达到一致
3. **最终一致性**：系统保证在没有新更新的情况下，最终达到一致

**项目中的一致性保证策略：**

**1. 强一致性场景：**
```java
// 订单支付场景
@GlobalTransactional
public void payOrder(Long orderId, PayInfoDTO payInfo) {
    // 1. 更新订单状态
    Order order = orderMapper.selectById(orderId);
    order.setStatus(OrderStatus.PAID.getValue());
    orderMapper.updateById(order);
    
    // 2. 记录支付信息
    PayInfo payment = new PayInfo();
    payment.setOrderId(orderId);
    payment.setAmount(payInfo.getAmount());
    payInfoMapper.insert(payment);
    
    // 3. 增加用户积分
    userClient.addPoints(order.getUserId(), order.getTotalFee() / 100);
    
    // 使用Seata保证强一致性
}
```

**2. 最终一致性场景：**
```java
// 使用消息队列实现最终一致性
@Service
public class OrderEventHandler {
    
    @RabbitListener(queues = "order.pay.queue")
    public void handleOrderPaid(OrderPaidEvent event) {
        try {
            // 1. 发送支付成功通知
            notificationService.sendPaySuccessNotification(event.getUserId());
            
            // 2. 更新用户统计信息
            userStatService.updateOrderCount(event.getUserId());
            
            // 3. 触发推荐算法更新
            recommendService.updateUserPreference(event.getUserId(), event.getItems());
            
        } catch (Exception e) {
            log.error("处理订单支付事件失败", e);
            // 重试机制保证最终一致性
            throw new AmqpRejectAndRequeueException("处理失败，重新入队");
        }
    }
}
```

**3. 补偿机制：**
```java
@Component
public class DataConsistencyChecker {
    
    @Scheduled(fixedDelay = 300000) // 5分钟检查一次
    public void checkOrderConsistency() {
        // 1. 查找状态不一致的订单
        List<Order> inconsistentOrders = findInconsistentOrders();
        
        for (Order order : inconsistentOrders) {
            try {
                // 2. 修复数据不一致
                repairOrderData(order);
                log.info("修复订单数据不一致，orderId: {}", order.getId());
            } catch (Exception e) {
                log.error("修复订单数据失败，orderId: {}", order.getId(), e);
            }
        }
    }
    
    private void repairOrderData(Order order) {
        // 根据业务规则修复数据
        if (order.getStatus() == OrderStatus.PAID.getValue()) {
            // 检查支付记录是否存在
            PayInfo payInfo = payInfoMapper.selectByOrderId(order.getId());
            if (payInfo == null) {
                // 支付记录缺失，可能需要人工介入
                alertService.sendAlert("订单支付记录缺失", order.getId());
            }
        }
    }
}
```

**4. 幂等性保证：**
```java
@Service
public class IdempotentService {
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    public boolean processWithIdempotent(String idempotentKey, Supplier<Boolean> business) {
        String lockKey = "lock:" + idempotentKey;
        String resultKey = "result:" + idempotentKey;
        
        // 1. 检查是否已经处理过
        String result = redisTemplate.opsForValue().get(resultKey);
        if (result != null) {
            return Boolean.parseBoolean(result);
        }
        
        // 2. 获取分布式锁
        Boolean lockAcquired = redisTemplate.opsForValue()
            .setIfAbsent(lockKey, "1", Duration.ofMinutes(5));
        
        if (!lockAcquired) {
            throw new BizIllegalException("请求处理中，请稍后重试");
        }
        
        try {
            // 3. 双重检查
            result = redisTemplate.opsForValue().get(resultKey);
            if (result != null) {
                return Boolean.parseBoolean(result);
            }
            
            // 4. 执行业务逻辑
            boolean success = business.get();
            
            // 5. 保存结果
            redisTemplate.opsForValue().set(resultKey, String.valueOf(success), Duration.ofHours(24));
            
            return success;
        } finally {
            // 6. 释放锁
            redisTemplate.delete(lockKey);
        }
    }
}
```

---

## 4. 分布式锁的实现方式有哪些？各有什么优缺点？

### 回答要点：

**分布式锁实现方式：**

**1. 基于Redis实现：**
```java
@Component
public class RedisDistributedLock {
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    private static final String LOCK_SCRIPT = 
        "if redis.call('get', KEYS[1]) == ARGV[1] then " +
        "return redis.call('del', KEYS[1]) " +
        "else return 0 end";
    
    public boolean tryLock(String key, String value, long expireTime) {
        Boolean result = redisTemplate.opsForValue()
            .setIfAbsent(key, value, Duration.ofMillis(expireTime));
        return Boolean.TRUE.equals(result);
    }
    
    public void unlock(String key, String value) {
        DefaultRedisScript<Long> script = new DefaultRedisScript<>();
        script.setScriptText(LOCK_SCRIPT);
        script.setResultType(Long.class);
        
        redisTemplate.execute(script, Collections.singletonList(key), value);
    }
}

// 使用示例
@Service
public class StockService {
    
    @Autowired
    private RedisDistributedLock distributedLock;
    
    public void deductStock(Long itemId, Integer count) {
        String lockKey = "stock:" + itemId;
        String lockValue = UUID.randomUUID().toString();
        
        if (distributedLock.tryLock(lockKey, lockValue, 30000)) {
            try {
                // 执行库存扣减逻辑
                Item item = itemMapper.selectById(itemId);
                if (item.getStock() < count) {
                    throw new BizIllegalException("库存不足");
                }
                
                item.setStock(item.getStock() - count);
                itemMapper.updateById(item);
                
            } finally {
                distributedLock.unlock(lockKey, lockValue);
            }
        } else {
            throw new BizIllegalException("系统繁忙，请稍后重试");
        }
    }
}
```

**Redis分布式锁优缺点：**
- 优点：性能高，实现简单，支持过期时间
- 缺点：可能存在锁失效问题，需要考虑Redis单点故障

**2. 基于Zookeeper实现：**
```java
@Component
public class ZookeeperDistributedLock {
    
    private CuratorFramework client;
    
    public InterProcessMutex createLock(String path) {
        return new InterProcessMutex(client, path);
    }
    
    public boolean tryLock(InterProcessMutex lock, long timeout, TimeUnit unit) {
        try {
            return lock.acquire(timeout, unit);
        } catch (Exception e) {
            log.error("获取分布式锁失败", e);
            return false;
        }
    }
    
    public void unlock(InterProcessMutex lock) {
        try {
            lock.release();
        } catch (Exception e) {
            log.error("释放分布式锁失败", e);
        }
    }
}
```

**Zookeeper分布式锁优缺点：**
- 优点：强一致性，自动故障恢复，支持阻塞等待
- 缺点：性能相对较低，依赖Zookeeper集群

**3. 基于数据库实现：**
```sql
-- 创建锁表
CREATE TABLE distributed_lock (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    lock_key VARCHAR(255) UNIQUE NOT NULL,
    lock_value VARCHAR(255) NOT NULL,
    expire_time TIMESTAMP NOT NULL,
    create_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

```java
@Repository
public class DatabaseDistributedLock {
    
    public boolean tryLock(String lockKey, String lockValue, long expireTime) {
        try {
            String sql = "INSERT INTO distributed_lock (lock_key, lock_value, expire_time) VALUES (?, ?, ?)";
            int result = jdbcTemplate.update(sql, lockKey, lockValue, 
                new Timestamp(System.currentTimeMillis() + expireTime));
            return result > 0;
        } catch (DuplicateKeyException e) {
            return false;
        }
    }
    
    public void unlock(String lockKey, String lockValue) {
        String sql = "DELETE FROM distributed_lock WHERE lock_key = ? AND lock_value = ?";
        jdbcTemplate.update(sql, lockKey, lockValue);
    }
    
    @Scheduled(fixedDelay = 60000)
    public void cleanExpiredLocks() {
        String sql = "DELETE FROM distributed_lock WHERE expire_time < NOW()";
        int count = jdbcTemplate.update(sql);
        if (count > 0) {
            log.info("清理过期锁: {} 个", count);
        }
    }
}
```

**数据库分布式锁优缺点：**
- 优点：实现简单，强一致性，易于理解
- 缺点：性能较差，可能成为瓶颈，需要定期清理

**选择建议：**
- **高性能场景**：选择Redis实现
- **强一致性要求**：选择Zookeeper实现
- **简单场景**：选择数据库实现
- **生产环境**：建议使用Redisson等成熟框架

---

## 5. 如何解决分布式系统中的幂等性问题？

### 回答要点：

**幂等性定义：**
同一个操作执行多次，结果应该是相同的，不会因为重复执行而产生副作用。

**项目中的幂等性场景：**

**1. 接口幂等性：**
```java
@RestController
public class OrderController {
    
    @PostMapping("/orders")
    public Result<Long> createOrder(@RequestBody OrderFormDTO orderForm,
                                   @RequestHeader("Idempotent-Key") String idempotentKey) {
        
        // 使用幂等性服务处理
        Long orderId = idempotentService.processWithIdempotent(
            idempotentKey,
            () -> orderService.createOrder(orderForm)
        );
        
        return Result.ok(orderId);
    }
}
```

**2. 支付回调幂等性：**
```java
@Service
public class PayCallbackService {
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    public void handlePayCallback(PayCallbackDTO callback) {
        String idempotentKey = "pay_callback:" + callback.getOutTradeNo();
        
        // 使用Redis实现幂等性控制
        Boolean lockAcquired = redisTemplate.opsForValue()
            .setIfAbsent(idempotentKey, "processing", Duration.ofMinutes(10));
        
        if (!lockAcquired) {
            log.info("支付回调重复处理，订单号: {}", callback.getOutTradeNo());
            return;
        }
        
        try {
            // 1. 查询订单状态
            Order order = orderService.getByOrderNo(callback.getOutTradeNo());
            if (order.getStatus() == OrderStatus.PAID.getValue()) {
                log.info("订单已支付，无需重复处理，订单号: {}", callback.getOutTradeNo());
                return;
            }
            
            // 2. 更新订单状态
            orderService.markOrderAsPaid(order.getId(), callback);
            
            // 3. 发送支付成功消息
            rabbitTemplate.convertAndSend("order.pay.topic", 
                new OrderPaidEvent(order.getId(), order.getUserId()));
            
            // 4. 标记处理完成
            redisTemplate.opsForValue().set(idempotentKey, "completed", Duration.ofDays(7));
            
        } catch (Exception e) {
            log.error("处理支付回调失败", e);
            redisTemplate.delete(idempotentKey);
            throw e;
        }
    }
}
```

**3. 消息消费幂等性：**
```java
@Component
public class OrderMessageConsumer {
    
    @RabbitListener(queues = "order.create.queue")
    public void handleOrderCreate(OrderCreateEvent event, 
                                 @Header("spring_returned_message_correlation") String messageId) {
        
        String idempotentKey = "order_create:" + messageId;
        
        // 检查是否已处理
        if (isMessageProcessed(idempotentKey)) {
            log.info("消息已处理，跳过，messageId: {}", messageId);
            return;
        }
        
        try {
            // 处理业务逻辑
            processOrderCreate(event);
            
            // 标记消息已处理
            markMessageProcessed(idempotentKey);
            
        } catch (Exception e) {
            log.error("处理订单创建消息失败，messageId: {}", messageId, e);
            throw new AmqpRejectAndRequeueException("处理失败，重新入队");
        }
    }
    
    private boolean isMessageProcessed(String key) {
        return redisTemplate.hasKey(key);
    }
    
    private void markMessageProcessed(String key) {
        redisTemplate.opsForValue().set(key, "1", Duration.ofDays(7));
    }
}
```

**4. 数据库层面幂等性：**
```java
@Service
public class UserPointsService {
    
    public void addPoints(Long userId, Integer points, String businessId) {
        // 使用唯一约束保证幂等性
        try {
            PointsRecord record = new PointsRecord();
            record.setUserId(userId);
            record.setPoints(points);
            record.setBusinessId(businessId); // 业务唯一标识
            record.setType(PointsType.ORDER_REWARD.getValue());
            
            pointsRecordMapper.insert(record);
            
            // 更新用户总积分
            userMapper.addPoints(userId, points);
            
        } catch (DuplicateKeyException e) {
            log.info("积分记录已存在，跳过处理，userId: {}, businessId: {}", userId, businessId);
        }
    }
}
```

**幂等性实现策略总结：**

**1. 唯一标识符：**
- 客户端生成唯一请求ID
- 使用业务唯一标识（订单号、流水号）
- 消息队列的消息ID

**2. 状态检查：**
- 检查业务状态是否已变更
- 查询操作结果是否已存在

**3. 分布式锁：**
- Redis分布式锁
- 数据库悲观锁
- Zookeeper分布式锁

**4. 数据库约束：**
- 唯一索引约束
- 版本号机制
- 乐观锁更新

**最佳实践：**
- 在接口设计时就考虑幂等性
- 选择合适的幂等性实现策略
- 设置合理的幂等性窗口期
- 做好异常处理和日志记录
- 定期清理幂等性相关数据