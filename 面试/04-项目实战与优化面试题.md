# 项目实战与优化面试题

## 1. 在HMall项目中遇到过哪些性能问题？是如何解决的？

### 回答要点：

**常见性能问题及解决方案：**

**1. 数据库查询性能问题：**

**问题描述：**
商品列表查询在数据量增大后响应时间从100ms增长到2000ms以上。

**问题分析：**
```sql
-- 原始查询（性能差）
SELECT * FROM tb_item 
WHERE category_id = ? 
AND status = 1 
AND name LIKE '%关键词%'
ORDER BY update_time DESC 
LIMIT 20;
```

**解决方案：**
```java
// 1. 添加复合索引
// ALTER TABLE tb_item ADD INDEX idx_category_status_update (category_id, status, update_time);

// 2. 优化查询逻辑
@Service
public class ItemService {
    
    public PageDTO<ItemVO> queryItemPage(ItemQuery query) {
        // 使用MyBatis Plus的分页插件
        Page<Item> page = new Page<>(query.getPageNo(), query.getPageSize());
        
        LambdaQueryWrapper<Item> wrapper = new LambdaQueryWrapper<Item>()
            .eq(Item::getCategoryId, query.getCategoryId())
            .eq(Item::getStatus, ItemStatus.NORMAL.getValue())
            .like(StringUtils.isNotBlank(query.getName()), Item::getName, query.getName())
            .orderByDesc(Item::getUpdateTime);
        
        Page<Item> itemPage = itemMapper.selectPage(page, wrapper);
        
        // 转换为VO并返回
        return PageDTO.of(itemPage, ItemVO.class);
    }
}

// 3. 引入搜索引擎（ElasticSearch）
@Service
public class ItemSearchService {
    
    @Autowired
    private ElasticsearchRestTemplate elasticsearchTemplate;
    
    public PageDTO<ItemVO> searchItems(ItemSearchQuery query) {
        // 构建搜索条件
        BoolQueryBuilder boolQuery = QueryBuilders.boolQuery()
            .must(QueryBuilders.termQuery("status", ItemStatus.NORMAL.getValue()))
            .must(QueryBuilders.termQuery("categoryId", query.getCategoryId()));
        
        if (StringUtils.isNotBlank(query.getKeyword())) {
            boolQuery.must(QueryBuilders.multiMatchQuery(query.getKeyword(), "name", "description"));
        }
        
        // 构建搜索请求
        NativeSearchQuery searchQuery = new NativeSearchQueryBuilder()
            .withQuery(boolQuery)
            .withSort(SortBuilders.fieldSort("updateTime").order(SortOrder.DESC))
            .withPageable(PageRequest.of(query.getPageNo() - 1, query.getPageSize()))
            .build();
        
        SearchHits<ItemDoc> searchHits = elasticsearchTemplate.search(searchQuery, ItemDoc.class);
        
        // 转换结果
        List<ItemVO> items = searchHits.stream()
            .map(hit -> BeanUtils.copyBean(hit.getContent(), ItemVO.class))
            .collect(Collectors.toList());
        
        return new PageDTO<>(searchHits.getTotalHits(), (long) query.getPageSize(), items);
    }
}
```

**效果：**
- 数据库查询优化后响应时间降至50ms
- 引入ES后复杂搜索响应时间稳定在100ms以内

**2. 缓存穿透和缓存雪崩问题：**

**问题描述：**
商品详情接口在高并发时出现大量数据库查询，Redis缓存失效时系统响应缓慢。

**解决方案：**
```java
@Service
public class ItemService {
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    @Autowired
    private ItemMapper itemMapper;
    
    // 解决缓存穿透：缓存空值
    public ItemVO getItemById(Long id) {
        String key = "item:" + id;
        
        // 1. 从缓存获取
        String json = redisTemplate.opsForValue().get(key);
        if (json != null) {
            if ("null".equals(json)) {
                return null; // 缓存的空值
            }
            return JsonUtils.toBean(json, ItemVO.class);
        }
        
        // 2. 缓存未命中，查询数据库
        Item item = itemMapper.selectById(id);
        
        if (item == null) {
            // 缓存空值，防止缓存穿透
            redisTemplate.opsForValue().set(key, "null", Duration.ofMinutes(5));
            return null;
        }
        
        // 3. 存入缓存，添加随机过期时间防止缓存雪崩
        ItemVO itemVO = BeanUtils.copyBean(item, ItemVO.class);
        int randomExpire = 30 + new Random().nextInt(10); // 30-40分钟随机过期
        redisTemplate.opsForValue().set(key, JsonUtils.toJsonStr(itemVO), Duration.ofMinutes(randomExpire));
        
        return itemVO;
    }
    
    // 解决缓存击穿：分布式锁
    public ItemVO getHotItemById(Long id) {
        String key = "item:" + id;
        String lockKey = "lock:item:" + id;
        
        // 1. 从缓存获取
        String json = redisTemplate.opsForValue().get(key);
        if (json != null) {
            return JsonUtils.toBean(json, ItemVO.class);
        }
        
        // 2. 获取分布式锁
        Boolean lockAcquired = redisTemplate.opsForValue()
            .setIfAbsent(lockKey, "1", Duration.ofSeconds(10));
        
        if (lockAcquired) {
            try {
                // 双重检查
                json = redisTemplate.opsForValue().get(key);
                if (json != null) {
                    return JsonUtils.toBean(json, ItemVO.class);
                }
                
                // 查询数据库
                Item item = itemMapper.selectById(id);
                if (item != null) {
                    ItemVO itemVO = BeanUtils.copyBean(item, ItemVO.class);
                    redisTemplate.opsForValue().set(key, JsonUtils.toJsonStr(itemVO), Duration.ofMinutes(30));
                    return itemVO;
                }
                
            } finally {
                redisTemplate.delete(lockKey);
            }
        } else {
            // 未获取到锁，等待后重试
            try {
                Thread.sleep(50);
                return getHotItemById(id);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                throw new RuntimeException(e);
            }
        }
        
        return null;
    }
}
```

**3. 服务调用超时问题：**

**问题描述：**
订单创建时调用库存服务偶尔超时，导致用户体验差。

**解决方案：**
```java
// 1. 优化Feign配置
@Configuration
public class FeignConfig {
    
    @Bean
    public Request.Options options() {
        return new Request.Options(
            5000,  // 连接超时时间
            10000, // 读取超时时间
            true   // 跟随重定向
        );
    }
    
    @Bean
    public Retryer retryer() {
        // 重试配置：初始间隔100ms，最大间隔1s，最大重试3次
        return new Retryer.Default(100, 1000, 3);
    }
}

// 2. 实现熔断降级
@Component
public class ItemClientFallback implements FallbackFactory<ItemClient> {
    
    @Override
    public ItemClient create(Throwable cause) {
        log.error("商品服务调用失败", cause);
        
        return new ItemClient() {
            @Override
            public void deductStock(List<OrderDetailDTO> items) {
                // 降级处理：记录失败信息，后续补偿
                log.error("库存扣减失败，订单商品: {}", JsonUtils.toJsonStr(items));
                throw new BizIllegalException("库存服务暂时不可用，请稍后重试");
            }
        };
    }
}

// 3. 异步处理优化
@Service
public class OrderService {
    
    @Async("taskExecutor")
    public CompletableFuture<Void> processOrderAsync(Long orderId) {
        return CompletableFuture.runAsync(() -> {
            // 异步处理订单相关逻辑
            sendOrderNotification(orderId);
            updateUserStatistics(orderId);
            syncOrderToDataWarehouse(orderId);
        });
    }
}
```

---

## 2. 如何设计和实现多级缓存架构？

### 回答要点：

**多级缓存架构设计：**

```
浏览器缓存 → CDN缓存 → Nginx缓存 → 应用缓存(Caffeine) → Redis缓存 → 数据库
```

**具体实现：**

**1. 应用级缓存（Caffeine）：**
```java
@Configuration
public class CacheConfig {
    
    @Bean
    public Cache<String, Object> localCache() {
        return Caffeine.newBuilder()
            .maximumSize(10000)  // 最大缓存数量
            .expireAfterWrite(Duration.ofMinutes(10))  // 写入后10分钟过期
            .expireAfterAccess(Duration.ofMinutes(5))  // 访问后5分钟过期
            .recordStats()  // 开启统计
            .build();
    }
}

@Service
public class CacheService {
    
    @Autowired
    private Cache<String, Object> localCache;
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    public <T> T get(String key, Class<T> type, Supplier<T> supplier) {
        // 1. 先查本地缓存
        Object value = localCache.getIfPresent(key);
        if (value != null) {
            return (T) value;
        }
        
        // 2. 查Redis缓存
        String json = redisTemplate.opsForValue().get(key);
        if (json != null) {
            T result = JsonUtils.toBean(json, type);
            // 回写本地缓存
            localCache.put(key, result);
            return result;
        }
        
        // 3. 查数据库
        T result = supplier.get();
        if (result != null) {
            // 写入Redis
            redisTemplate.opsForValue().set(key, JsonUtils.toJsonStr(result), Duration.ofMinutes(30));
            // 写入本地缓存
            localCache.put(key, result);
        }
        
        return result;
    }
}
```

**2. 分布式缓存（Redis）：**
```java
@Service
public class ItemCacheService {
    
    @Autowired
    private CacheService cacheService;
    
    @Autowired
    private ItemMapper itemMapper;
    
    public ItemVO getItemById(Long id) {
        String key = "item:" + id;
        
        return cacheService.get(key, ItemVO.class, () -> {
            Item item = itemMapper.selectById(id);
            return item != null ? BeanUtils.copyBean(item, ItemVO.class) : null;
        });
    }
    
    // 缓存预热
    @PostConstruct
    public void warmUpCache() {
        log.info("开始缓存预热...");
        
        // 预热热门商品
        List<Long> hotItemIds = getHotItemIds();
        for (Long itemId : hotItemIds) {
            try {
                getItemById(itemId);
                Thread.sleep(10); // 避免对数据库造成压力
            } catch (Exception e) {
                log.error("预热商品缓存失败，itemId: {}", itemId, e);
            }
        }
        
        log.info("缓存预热完成，预热商品数量: {}", hotItemIds.size());
    }
}
```

**3. HTTP缓存策略：**
```java
@RestController
public class ItemController {
    
    @GetMapping("/items/{id}")
    public ResponseEntity<ItemVO> getItemById(@PathVariable Long id) {
        ItemVO item = itemService.getItemById(id);
        
        if (item == null) {
            return ResponseEntity.notFound().build();
        }
        
        // 设置缓存头
        return ResponseEntity.ok()
            .cacheControl(CacheControl.maxAge(Duration.ofMinutes(10)))
            .eTag(String.valueOf(item.getUpdateTime().hashCode()))
            .body(item);
    }
    
    @GetMapping("/items/category/{categoryId}")
    public ResponseEntity<List<ItemVO>> getItemsByCategory(@PathVariable Long categoryId) {
        List<ItemVO> items = itemService.getItemsByCategory(categoryId);
        
        // 对于列表数据，设置较短的缓存时间
        return ResponseEntity.ok()
            .cacheControl(CacheControl.maxAge(Duration.ofMinutes(5)))
            .body(items);
    }
}
```

**4. 缓存一致性保证：**
```java
@Service
public class ItemService {
    
    @Autowired
    private ItemMapper itemMapper;
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    @Autowired
    private Cache<String, Object> localCache;
    
    @Transactional
    public void updateItem(ItemDTO itemDTO) {
        // 1. 更新数据库
        Item item = BeanUtils.copyBean(itemDTO, Item.class);
        itemMapper.updateById(item);
        
        // 2. 删除缓存（延时双删策略）
        String key = "item:" + item.getId();
        deleteCache(key);
        
        // 3. 延时删除，防止脏数据
        CompletableFuture.runAsync(() -> {
            try {
                Thread.sleep(1000); // 延时1秒
                deleteCache(key);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });
        
        // 4. 发送缓存失效消息
        rabbitTemplate.convertAndSend("cache.invalidate.topic", 
            new CacheInvalidateEvent("item", item.getId()));
    }
    
    private void deleteCache(String key) {
        // 删除本地缓存
        localCache.invalidate(key);
        // 删除Redis缓存
        redisTemplate.delete(key);
    }
}

// 缓存失效消息处理
@Component
public class CacheInvalidateListener {
    
    @RabbitListener(queues = "cache.invalidate.queue")
    public void handleCacheInvalidate(CacheInvalidateEvent event) {
        String key = event.getType() + ":" + event.getId();
        localCache.invalidate(key);
        log.info("本地缓存失效: {}", key);
    }
}
```

---

## 3. 如何处理高并发场景下的库存扣减问题？

### 回答要点：

**高并发库存扣减挑战：**
1. 超卖问题：库存扣减为负数
2. 性能问题：大量并发请求导致数据库压力
3. 一致性问题：分布式环境下数据一致性

**解决方案演进：**

**1. 数据库乐观锁方案：**
```java
@Service
public class StockService {
    
    @Autowired
    private ItemMapper itemMapper;
    
    @Transactional
    public boolean deductStock(Long itemId, Integer count) {
        // 乐观锁更新
        int updated = itemMapper.deductStock(itemId, count);
        return updated > 0;
    }
}

// Mapper实现
@Mapper
public interface ItemMapper extends BaseMapper<Item> {
    
    @Update("UPDATE tb_item SET stock = stock - #{count} " +
            "WHERE id = #{itemId} AND stock >= #{count}")
    int deductStock(@Param("itemId") Long itemId, @Param("count") Integer count);
}
```

**问题：**
- 高并发时大量请求失败，用户体验差
- 数据库压力大

**2. Redis分布式锁方案：**
```java
@Service
public class StockService {
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    @Autowired
    private ItemMapper itemMapper;
    
    public boolean deductStock(Long itemId, Integer count) {
        String lockKey = "stock_lock:" + itemId;
        String lockValue = UUID.randomUUID().toString();
        
        // 获取分布式锁
        Boolean lockAcquired = redisTemplate.opsForValue()
            .setIfAbsent(lockKey, lockValue, Duration.ofSeconds(10));
        
        if (!lockAcquired) {
            throw new BizIllegalException("系统繁忙，请稍后重试");
        }
        
        try {
            // 查询当前库存
            Item item = itemMapper.selectById(itemId);
            if (item.getStock() < count) {
                return false;
            }
            
            // 扣减库存
            item.setStock(item.getStock() - count);
            itemMapper.updateById(item);
            
            return true;
            
        } finally {
            // 释放锁
            String script = "if redis.call('get', KEYS[1]) == ARGV[1] then " +
                           "return redis.call('del', KEYS[1]) else return 0 end";
            redisTemplate.execute(new DefaultRedisScript<>(script, Long.class), 
                Collections.singletonList(lockKey), lockValue);
        }
    }
}
```

**3. Redis预扣库存方案：**
```java
@Service
public class StockService {
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    @Autowired
    private RabbitTemplate rabbitTemplate;
    
    // 初始化Redis库存
    public void initStock(Long itemId, Integer stock) {
        String key = "stock:" + itemId;
        redisTemplate.opsForValue().set(key, stock.toString());
    }
    
    // Redis预扣库存
    public boolean preDeductStock(Long itemId, Integer count) {
        String key = "stock:" + itemId;
        
        // Lua脚本保证原子性
        String script = 
            "local stock = redis.call('get', KEYS[1]) " +
            "if not stock then return -1 end " +
            "stock = tonumber(stock) " +
            "if stock >= tonumber(ARGV[1]) then " +
            "  redis.call('decrby', KEYS[1], ARGV[1]) " +
            "  return stock - tonumber(ARGV[1]) " +
            "else " +
            "  return -1 " +
            "end";
        
        DefaultRedisScript<Long> redisScript = new DefaultRedisScript<>();
        redisScript.setScriptText(script);
        redisScript.setResultType(Long.class);
        
        Long result = redisTemplate.execute(redisScript, 
            Collections.singletonList(key), count.toString());
        
        if (result >= 0) {
            // 预扣成功，发送消息进行数据库扣减
            StockDeductEvent event = new StockDeductEvent(itemId, count);
            rabbitTemplate.convertAndSend("stock.deduct.topic", event);
            return true;
        }
        
        return false;
    }
    
    // 异步处理数据库库存扣减
    @RabbitListener(queues = "stock.deduct.queue")
    public void handleStockDeduct(StockDeductEvent event) {
        try {
            // 数据库扣减库存
            int updated = itemMapper.deductStock(event.getItemId(), event.getCount());
            
            if (updated == 0) {
                // 数据库扣减失败，回滚Redis库存
                rollbackRedisStock(event.getItemId(), event.getCount());
                log.error("数据库库存扣减失败，已回滚Redis库存，itemId: {}, count: {}", 
                    event.getItemId(), event.getCount());
            }
            
        } catch (Exception e) {
            // 异常情况下回滚Redis库存
            rollbackRedisStock(event.getItemId(), event.getCount());
            log.error("库存扣减异常，已回滚Redis库存", e);
            throw new AmqpRejectAndRequeueException("库存扣减失败，重新入队");
        }
    }
    
    private void rollbackRedisStock(Long itemId, Integer count) {
        String key = "stock:" + itemId;
        redisTemplate.opsForValue().increment(key, count);
    }
}
```

**4. 分段锁优化方案：**
```java
@Service
public class SegmentStockService {
    
    private static final int SEGMENT_COUNT = 10; // 分段数量
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    // 初始化分段库存
    public void initSegmentStock(Long itemId, Integer totalStock) {
        int stockPerSegment = totalStock / SEGMENT_COUNT;
        int remainder = totalStock % SEGMENT_COUNT;
        
        for (int i = 0; i < SEGMENT_COUNT; i++) {
            String key = "stock:" + itemId + ":segment:" + i;
            int segmentStock = stockPerSegment + (i < remainder ? 1 : 0);
            redisTemplate.opsForValue().set(key, String.valueOf(segmentStock));
        }
    }
    
    public boolean deductStock(Long itemId, Integer count) {
        // 随机选择分段，减少锁竞争
        int segment = ThreadLocalRandom.current().nextInt(SEGMENT_COUNT);
        
        for (int i = 0; i < SEGMENT_COUNT; i++) {
            int currentSegment = (segment + i) % SEGMENT_COUNT;
            String key = "stock:" + itemId + ":segment:" + currentSegment;
            
            if (tryDeductSegmentStock(key, count)) {
                return true;
            }
        }
        
        return false;
    }
    
    private boolean tryDeductSegmentStock(String key, Integer count) {
        String script = 
            "local stock = redis.call('get', KEYS[1]) " +
            "if not stock then return -1 end " +
            "stock = tonumber(stock) " +
            "if stock >= tonumber(ARGV[1]) then " +
            "  redis.call('decrby', KEYS[1], ARGV[1]) " +
            "  return 1 " +
            "else " +
            "  return 0 " +
            "end";
        
        DefaultRedisScript<Long> redisScript = new DefaultRedisScript<>();
        redisScript.setScriptText(script);
        redisScript.setResultType(Long.class);
        
        Long result = redisTemplate.execute(redisScript, 
            Collections.singletonList(key), count.toString());
        
        return result != null && result == 1;
    }
}
```

**性能对比：**
- 数据库乐观锁：QPS ~1000，成功率60%
- Redis分布式锁：QPS ~3000，成功率95%
- Redis预扣库存：QPS ~8000，成功率99%
- 分段锁优化：QPS ~15000，成功率99%

---

## 4. 如何设计系统的监控和告警机制？

### 回答要点：

**监控体系架构：**

```
应用监控(Micrometer) → 指标收集(Prometheus) → 可视化(Grafana) → 告警(AlertManager)
```

**1. 应用指标监控：**
```java
@Configuration
public class MetricsConfig {
    
    @Bean
    public MeterRegistry meterRegistry() {
        return new PrometheusMeterRegistry(PrometheusConfig.DEFAULT);
    }
    
    @Bean
    public TimedAspect timedAspect(MeterRegistry registry) {
        return new TimedAspect(registry);
    }
}

@RestController
public class OrderController {
    
    @Autowired
    private MeterRegistry meterRegistry;
    
    @PostMapping("/orders")
    @Timed(name = "order.create", description = "订单创建耗时")
    public Result<Long> createOrder(@RequestBody OrderFormDTO orderForm) {
        
        // 自定义指标统计
        Counter orderCounter = Counter.builder("order.create.count")
            .description("订单创建次数")
            .tag("status", "success")
            .register(meterRegistry);
        
        try {
            Long orderId = orderService.createOrder(orderForm);
            orderCounter.increment();
            return Result.ok(orderId);
            
        } catch (Exception e) {
            Counter.builder("order.create.count")
                .description("订单创建次数")
                .tag("status", "error")
                .register(meterRegistry)
                .increment();
            throw e;
        }
    }
}
```

**2. 业务指标监控：**
```java
@Component
public class BusinessMetrics {
    
    @Autowired
    private MeterRegistry meterRegistry;
    
    // 订单金额分布
    @EventListener
    public void handleOrderCreated(OrderCreatedEvent event) {
        DistributionSummary.builder("order.amount")
            .description("订单金额分布")
            .register(meterRegistry)
            .record(event.getTotalAmount());
    }
    
    // 库存告警
    @Scheduled(fixedDelay = 60000)
    public void checkLowStock() {
        List<Item> lowStockItems = itemService.getLowStockItems(10);
        
        Gauge.builder("stock.low.count")
            .description("低库存商品数量")
            .register(meterRegistry, lowStockItems, List::size);
        
        // 发送告警
        if (!lowStockItems.isEmpty()) {
            alertService.sendLowStockAlert(lowStockItems);
        }
    }
    
    // 用户活跃度
    @EventListener
    public void handleUserLogin(UserLoginEvent event) {
        Counter.builder("user.login.count")
            .description("用户登录次数")
            .tag("hour", String.valueOf(LocalDateTime.now().getHour()))
            .register(meterRegistry)
            .increment();
    }
}
```

**3. 系统健康检查：**
```java
@Component
public class CustomHealthIndicator implements HealthIndicator {
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    @Autowired
    private DataSource dataSource;
    
    @Override
    public Health health() {
        Health.Builder builder = new Health.Builder();
        
        try {
            // 检查Redis连接
            redisTemplate.opsForValue().get("health_check");
            builder.withDetail("redis", "UP");
            
            // 检查数据库连接
            try (Connection connection = dataSource.getConnection()) {
                if (connection.isValid(3)) {
                    builder.withDetail("database", "UP");
                } else {
                    builder.withDetail("database", "DOWN");
                    return builder.down().build();
                }
            }
            
            // 检查外部服务
            boolean itemServiceHealthy = checkServiceHealth("item-service");
            builder.withDetail("item-service", itemServiceHealthy ? "UP" : "DOWN");
            
            return builder.up().build();
            
        } catch (Exception e) {
            return builder.down(e).build();
        }
    }
    
    private boolean checkServiceHealth(String serviceName) {
        try {
            // 调用服务健康检查接口
            String url = "http://" + serviceName + "/actuator/health";
            RestTemplate restTemplate = new RestTemplate();
            ResponseEntity<String> response = restTemplate.getForEntity(url, String.class);
            return response.getStatusCode().is2xxSuccessful();
        } catch (Exception e) {
            return false;
        }
    }
}
```

**4. 告警规则配置：**
```yaml
# prometheus.yml
rule_files:
  - "alert_rules.yml"

# alert_rules.yml
groups:
  - name: hmall-alerts
    rules:
      # 服务可用性告警
      - alert: ServiceDown
        expr: up == 0
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: "服务 {{ $labels.instance }} 不可用"
          description: "服务已下线超过1分钟"
      
      # 响应时间告警
      - alert: HighResponseTime
        expr: http_request_duration_seconds{quantile="0.95"} > 2
        for: 2m
        labels:
          severity: warning
        annotations:
          summary: "{{ $labels.job }} 响应时间过高"
          description: "95%请求响应时间超过2秒"
      
      # 错误率告警
      - alert: HighErrorRate
        expr: rate(http_requests_total{status=~"5.."}[5m]) / rate(http_requests_total[5m]) > 0.1
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: "{{ $labels.job }} 错误率过高"
          description: "5分钟内错误率超过10%"
      
      # 内存使用告警
      - alert: HighMemoryUsage
        expr: (1 - (node_memory_MemAvailable_bytes / node_memory_MemTotal_bytes)) * 100 > 80
        for: 2m
        labels:
          severity: warning
        annotations:
          summary: "内存使用率过高"
          description: "内存使用率超过80%"
```

**5. 告警通知实现：**
```java
@Service
public class AlertService {
    
    @Value("${alert.webhook.url}")
    private String webhookUrl;
    
    @Autowired
    private RestTemplate restTemplate;
    
    public void sendAlert(AlertMessage alert) {
        try {
            // 发送到钉钉群
            sendToDingTalk(alert);
            
            // 发送邮件
            sendEmail(alert);
            
            // 发送短信（严重告警）
            if ("critical".equals(alert.getSeverity())) {
                sendSms(alert);
            }
            
        } catch (Exception e) {
            log.error("发送告警失败", e);
        }
    }
    
    private void sendToDingTalk(AlertMessage alert) {
        Map<String, Object> message = new HashMap<>();
        message.put("msgtype", "text");
        
        Map<String, String> text = new HashMap<>();
        text.put("content", String.format("【%s】%s\n时间：%s\n详情：%s", 
            alert.getSeverity().toUpperCase(),
            alert.getSummary(),
            alert.getTimestamp(),
            alert.getDescription()));
        
        message.put("text", text);
        
        restTemplate.postForObject(webhookUrl, message, String.class);
    }
    
    public void sendLowStockAlert(List<Item> lowStockItems) {
        StringBuilder content = new StringBuilder("【库存告警】以下商品库存不足：\n");
        
        for (Item item : lowStockItems) {
            content.append(String.format("- %s (ID:%d) 剩余库存：%d\n", 
                item.getName(), item.getId(), item.getStock()));
        }
        
        AlertMessage alert = AlertMessage.builder()
            .severity("warning")
            .summary("商品库存不足")
            .description(content.toString())
            .timestamp(LocalDateTime.now())
            .build();
        
        sendAlert(alert);
    }
}
```

**监控大盘指标：**
- **系统指标**：CPU、内存、磁盘、网络使用率
- **应用指标**：QPS、响应时间、错误率、JVM指标
- **业务指标**：订单量、支付成功率、用户活跃度
- **基础设施**：数据库连接数、Redis内存使用、消息队列积压

---

## 5. 如何进行系统的压力测试和性能调优？

### 回答要点：

**压力测试策略：**

**1. 测试环境准备：**
```yaml
# docker-compose-test.yml
version: '3.8'
services:
  mysql:
    image: mysql:8.0.23
    environment:
      MYSQL_ROOT_PASSWORD: 123456
    command: |
      --max-connections=1000
      --innodb-buffer-pool-size=1G
      --innodb-log-file-size=256M
  
  redis:
    image: redis:6.2
    command: redis-server --maxmemory 512mb --maxmemory-policy allkeys-lru
  
  hmall-gateway:
    image: hmall-gateway:latest
    environment:
      - JAVA_OPTS=-Xms512m -Xmx1g -XX:+UseG1GC
    deploy:
      replicas: 2
```

**2. JMeter压测脚本：**
```xml
<!-- 订单创建压测 -->
<TestPlan>
  <ThreadGroup>
    <stringProp name="ThreadGroup.num_threads">100</stringProp>
    <stringProp name="ThreadGroup.ramp_time">60</stringProp>
    <stringProp name="ThreadGroup.duration">300</stringProp>
    
    <HTTPSamplerProxy>
      <stringProp name="HTTPSampler.domain">localhost</stringProp>
      <stringProp name="HTTPSampler.port">8080</stringProp>
      <stringProp name="HTTPSampler.path">/orders</stringProp>
      <stringProp name="HTTPSampler.method">POST</stringProp>
      <stringProp name="HTTPSampler.postBodyRaw">{
        "cartIds": [1, 2, 3],
        "addressId": 1,
        "paymentType": 1
      }</stringProp>
    </HTTPSamplerProxy>
  </ThreadGroup>
</TestPlan>
```

**3. 性能基线建立：**
```java
@Component
public class PerformanceMonitor {
    
    @Autowired
    private MeterRegistry meterRegistry;
    
    @EventListener
    public void recordPerformanceBaseline(ApplicationReadyEvent event) {
        // 记录启动时的性能基线
        Timer.Sample sample = Timer.start(meterRegistry);
        
        // 执行基准测试
        runBenchmarkTests();
        
        sample.stop(Timer.builder("app.startup.time")
            .description("应用启动时间")
            .register(meterRegistry));
    }
    
    private void runBenchmarkTests() {
        // 数据库连接测试
        Timer.Sample dbSample = Timer.start(meterRegistry);
        testDatabaseConnection();
        dbSample.stop(Timer.builder("benchmark.db.connection")
            .register(meterRegistry));
        
        // Redis连接测试
        Timer.Sample redisSample = Timer.start(meterRegistry);
        testRedisConnection();
        redisSample.stop(Timer.builder("benchmark.redis.connection")
            .register(meterRegistry));
    }
}
```

**4. 性能调优实践：**

**JVM调优：**
```bash
# 生产环境JVM参数
JAVA_OPTS="
-Xms2g -Xmx2g
-XX:+UseG1GC
-XX:MaxGCPauseMillis=200
-XX:+UnlockExperimentalVMOptions
-XX:+UseStringDeduplication
-XX:+PrintGCDetails
-XX:+PrintGCTimeStamps
-Xloggc:/var/log/gc.log
-XX:+UseGCLogFileRotation
-XX:NumberOfGCLogFiles=5
-XX:GCLogFileSize=10M
"
```

**数据库连接池调优：**
```yaml
spring:
  datasource:
    hikari:
      maximum-pool-size: 20
      minimum-idle: 5
      connection-timeout: 30000
      idle-timeout: 600000
      max-lifetime: 1800000
      leak-detection-threshold: 60000
```

**Redis连接池调优：**
```yaml
spring:
  redis:
    lettuce:
      pool:
        max-active: 20
        max-idle: 8
        min-idle: 2
        max-wait: 3000ms
    timeout: 5000ms
```

**5. 性能优化案例：**

**案例1：订单查询优化**
```java
// 优化前：N+1查询问题
@Service
public class OrderService {
    
    public List<OrderVO> getOrderList(Long userId) {
        List<Order> orders = orderMapper.selectByUserId(userId);
        
        return orders.stream().map(order -> {
            OrderVO vo = BeanUtils.copyBean(order, OrderVO.class);
            
            // N+1查询问题
            List<OrderDetail> details = orderDetailMapper.selectByOrderId(order.getId());
            vo.setDetails(BeanUtils.copyList(details, OrderDetailVO.class));
            
            return vo;
        }).collect(Collectors.toList());
    }
}

// 优化后：批量查询
@Service
public class OrderService {
    
    public List<OrderVO> getOrderList(Long userId) {
        List<Order> orders = orderMapper.selectByUserId(userId);
        if (orders.isEmpty()) {
            return Collections.emptyList();
        }
        
        // 批量查询订单详情
        List<Long> orderIds = orders.stream()
            .map(Order::getId)
            .collect(Collectors.toList());
        
        List<OrderDetail> allDetails = orderDetailMapper.selectByOrderIds(orderIds);
        
        // 按订单ID分组
        Map<Long, List<OrderDetail>> detailMap = allDetails.stream()
            .collect(Collectors.groupingBy(OrderDetail::getOrderId));
        
        return orders.stream().map(order -> {
            OrderVO vo = BeanUtils.copyBean(order, OrderVO.class);
            List<OrderDetail> details = detailMap.getOrDefault(order.getId(), Collections.emptyList());
            vo.setDetails(BeanUtils.copyList(details, OrderDetailVO.class));
            return vo;
        }).collect(Collectors.toList());
    }
}
```

**性能提升：**
- 查询时间从平均500ms降至50ms
- 数据库连接数减少90%
- 系统吞吐量提升5倍

**案例2：缓存预热优化**
```java
@Component
public class CacheWarmUpService {
    
    @Autowired
    private ItemService itemService;
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    @EventListener
    public void warmUpCache(ApplicationReadyEvent event) {
        log.info("开始缓存预热...");
        
        CompletableFuture.runAsync(() -> {
            // 预热热门商品
            warmUpHotItems();
            
            // 预热分类数据
            warmUpCategories();
            
            // 预热配置数据
            warmUpConfigs();
            
            log.info("缓存预热完成");
        });
    }
    
    private void warmUpHotItems() {
        // 从数据分析系统获取热门商品ID
        List<Long> hotItemIds = getHotItemIds();
        
        // 并行预热，控制并发数
        hotItemIds.parallelStream()
            .forEach(itemId -> {
                try {
                    itemService.getItemById(itemId);
                    Thread.sleep(10); // 避免对数据库造成压力
                } catch (Exception e) {
                    log.error("预热商品缓存失败，itemId: {}", itemId, e);
                }
            });
    }
}
```

**压测结果对比：**

| 指标 | 优化前 | 优化后 | 提升幅度 |
|------|--------|--------|----------|
| QPS | 1000 | 5000 | 400% |
| 平均响应时间 | 200ms | 50ms | 75% |
| P99响应时间 | 2000ms | 200ms | 90% |
| CPU使用率 | 80% | 40% | 50% |
| 内存使用率 | 70% | 60% | 14% |

**持续优化策略：**
1. **定期压测**：每月进行一次全链路压测
2. **性能监控**：实时监控关键指标，设置告警阈值
3. **代码审查**：关注性能相关的代码变更
4. **容量规划**：根据业务增长预测，提前扩容
5. **技术升级**：跟进新技术，适时进行技术栈升级